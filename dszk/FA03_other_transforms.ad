= Other Transforms
:url: ./fa/other_transforms/
:page-group: fa
:page-order: FA03

== Cosine Transform

Discrete Cosine Transform (DCT)::
+
--
* Uses just stem:[\cos] functions.
* We don't use complex numbers anymore, but we also lose some of the nice properties of the transform.
* Good tool for compression, not so much for signal analysis.
* Coefficients are divided into "DC" (zero frequency) and "AC" (other frequencies).
--
+
**_Forward DCT:_**
+
[stem]
++++
C(k) = \alpha(k) \sum_{l=0}^{N-1} f(l) \cdot \left\lbrack \cos \frac{(2l + 1)\pi k}{2N} \right\rbrack,~k = \{0, 1, ... N-1\} \\

~~\text{where}~~ \\

\alpha(k) = \begin{cases}

\sqrt{\frac{1}{N}} ~\text{iff}~ k=0 \\

\sqrt{\frac{2}{N}} ~\text{iff}~ k\neq 0

\end{cases}
++++
+
**_Inverse DCT:_**
+
[stem]
++++
f(l) = \sum_{k=0}^{N-1} \alpha(k) \cdot C(k) \left\lbrack \cos \frac{(2l + 1) \pi k}{2N} \right\rbrack,~l = \{0, 1, ..., N-1\}
++++

Derivation of DCT::
1. Let's do the following transformation to the original signal stem:[f] of length stem:[N]:
+
image::./img/fa03_dct_example.png[]
+
[NOTE]
====
The addition of interleaved zeroes is the same as **stretching** the original signal.

stem:[c] is even (ready for DFT without complex number), has length stem:[4N], and the following is true:

[stem]
++++
\begin{aligned}

c(2n) &= 0 ~\text{iff}~ 0 \leq n < N \\
c(2n + 1) &= f(n) ~\text{iff}~ 0 \leq n < N \\
c(4N-n) &= c(n) ~\text{iff}~ 0 < n < 2N

\end{aligned}
++++
====
2. Apply DFT to stem:[c]:
+
[stem]
++++
\begin{aligned}

C(k) &= \sum_{j=0}^{4N-1} c(j) \cdot e^{-\frac{2\pi i j k}{4N}} = \text{/symmetry/} \\

&= \sum_{j=0}^{2N-1} c(j) \cdot \left\lbrack e^{\frac{2\pi i j k}{4N}} + e^{-\frac{2\pi i (4N - j) k}{4N}}\right\rbrack = \\

&= \sum_{j=0}^{2N-1} c(j) \cdot \left\lbrack e^{-\frac{2\pi i j k}{4N}} + e^{\frac{2\pi i j k}{4N}} \right\rbrack = \text{/Euler-Moivre eq./} \\

&= \sum_{j=0}^{2N-1} c(j) \cdot \left\lbrack \left( \cos \frac{2\pi j k}{4N} - i \sin \frac{2\pi j k}{4N} \right) + \left( \cos \frac{2\pi j k}{4N} + i \sin \frac{2 \pi j k}{4N} \right) \right\rbrack = \\

&= \sum_{j=0}^{2N-1} c(j) \cdot \left\lbrack 2 \cos \frac{2 \pi j k}{4N} \right\rbrack = \text{/split odd and even positions/}\\

&= \sum_{l=0}^{N-1} 2c(2l) \cdot \left\lbrack \cos{\frac{2\pi 2 l k}{4N}} \right\rbrack + \sum_{l=0}^{N-1} 2c(2l + 1) \cdot \left\lbrack \cos{\frac{2\pi (2l + 1) k}{4N}} \right\rbrack = \text{/c is 0 at even pos./} \\

&= \sum_{l=0}^{N-1} 2f(l) \cdot \left\lbrack \cos \frac{(2l + 1)\pi k}{2N} \right\rbrack ~~\text{(DCT-II)}


\end{aligned}
++++

Fast discrete cosine transform (F-DCT)::
+
--
1. Recombine signal stem:[f] of length stem:[N] to get stem:[y]:
+
[stem]
++++
y(l) = f(2l) \\
y(N - 1 - l) = f(2l + 1) ~ (l = 0, 1, ..., N/2-1)
++++
2. Run FFT on stem:[y].
3. For each stem:[k = 0, 1, ... N-1] do:
.. Multiply the k-th Fourier coefficient by factor stem:[e^{-\frac{\pi i k}{2N}}]:
+
[stem]
++++
Y'(k) = e^{\frac{\pi i k}{2 N}} \cdot Y(k)
++++
.. Get only the real part of each Fourier coefficient and normalize the results:
+
[stem]
++++
C(k) = \alpha(k) \cdot \text{Real}\lbrack Y'(k) \rbrack \cdot \sqrt{N}
++++
--
+
[NOTE]
====
The recombination step, which created stem:[y], is a clever hack of converting a sequence meant for DCT into something that can be digested by DFT, allowing us to use FFT inside FastDCT.
====


DCT in 2D::
+
image::./img/fa03_dct_2d_basis_functions.png[]

== Z-transform

Z-transform::
It's a generalization of the (discrete time) Fourier transform. Wheras DTFT projects stem:[f] on the unit circle in the complex plane, Z-transform uses the whole complex plane. Whereas DTFT can only analyze frequencies that are stable, Z-transform can also handle unstable or exploding signals (e.g., screaching sounds or the whole image turns white or black).
+
--
* It's used to check that recursive linear filters don't blow up to "infinite white" or are unstable.
* In optimizing DWT.
* Understanding and frequency analysis of linear filters.
* Forward Z-tranform converts discrete time series into a continuous signal (Z-plane).
* Forward Z-transform applied to discrete signals or linear filters always creats a polynomial with one variable stem:[z].
--
+
**_Bilateral forward Z-transform:_**
+
[stem]
++++
F(z) = \sum_{-\infty}^{\infty} f(n) z^{-n} ~\text{where}~ z \in \Complex
++++
+
**_Inverse Z-transform:_**
+
If stem:[F(z)] is a polynomial, that is stem:[F(z) = \sum_{k=-\infty}^{\infty} c_k z^{-k}], then
+
[stem]
++++
f(n) = \mathcal{Z}^{-1}(F(z)) = \sum_{k=-\infty}^{\infty} c_k \delta(n-k)
++++

Linear recursive filters::
The idea is that convolution is computationally expensive (stem:[\mathcal{O}(n^2)]) but if they could be recursive and use already-convolved neighbors as their input, the complexity would be lower (stem:[\mathcal{O}(n\log n)]).

== Wavelet Transform

Wavelet transform (WT)::
+
--
* Compared to FT, which captures global frequency information, WT provides temporal information as well.
* Uses wavelets -- functions with a peak at zero and brief, diminishing oscillations.
** The main idea is to constrain the basis functions in time ("wavelet" = "little wave").
** Parametrized both by **frequency and time**.
* It's not possible to have perfect information about time and frequency at the same time. WT is in the middle.
* A mother wavelet can be any function that satisfies the _wavelet constraints_.
* WT turns a 1D time function stem:[f(t)] into a 2D function of time and frequency stem:[T(a, b)].
* We translate the mother wavelet stem:[\psi] (shift it in time) or scale it (change its frequency).
** Translating stem:[\psi_b(t) = \psi(t-b)]
** Scaling stem:[\psi_a(t) = \psi(t/a)]
** Scaling and traslating stem:[\psi_{a,b} = \psi\left( \frac{t-b}{a} \right)]
* stem:[\psi_{a,b}] are the _daughter wavelets_.
* The mother wavelet is complex.
** If it were just real, then when WT would output zero it wouldn't necessarily mean that there is no wave of the specified frequency because the waves can cancel each other out instead of resonating. We use complex wavelets so that we can take the absolute value of the complex result and avoid this problem.
* Time vs frequency trade-off: High-time detail for high frequencies. High-frequency detail for low frequencies. 
--

Continuous Wavelet Transform (CWT)::
+
[stem]
++++

T(a, b) = \frac{1}{\sqrt{|a|}} \int_{-\infty}^{\infty} f(t) \cdot \overline{\psi_{a,b}(t)} dt
++++
+
[NOTE]
====
* We conjugate stem:[\psi_{a,b}] because it's complex and dot product works like that with complex numbers.
* The stem:[\frac{1}{\sqrt{|a|}}] is a normalization factor it preserves the "energy" of each stretched daughter wavelet so we treat them equally.
====

Wavelet constraints::
Function stem:[\psi(t)] is a wavelet if:
1. Admissability condition: It has zero mean. There is no zero frequency component.
+
[stem]
++++
\int_{-\infty}^{\infty} \psi(t) dt = 0
++++
2. Has finite energy. This makes it localized in time.
+
[stem]
++++
\int_{-\infty}^{\infty} |\psi(t)|^2 dt < \infty
++++

Well-known mother wavelets::
* _Haar_ -- The original wavelet used in DWT. Most educational.
* _Morlet_ -- Complex exponential (stem:[e^{ix}]) + Gaussian. First wavelet used in CWT.
* _Daubechies_
* _Shannon_
* _Meyer_
* _Mexican hat_
* _triangular_

.The Haar Wavelet
image::./img/fa03_haar_wavelet.png[]

== Discrete Wavelet Transform

Discrete wavelet transform (DWT)::
Any WT where the wavelets are discretely sampled. In the following general definition, the original signal stem:[f] has length stem:[M = 2^J] and stem:[j \in \{j_0, ..., J-1\}] is the decomposition level.
+
--
* All computations are performed with floating point numbers. No complex numbers are used.
* One forward step is between two consecutive decomposition levels is just **separation** of low and high frequencies.
* One backward step between two consecutive decomposition levels is just **merging** of low and high frequencies.
* The complete decomposition of a signal can be done step by step (i.e., recursively) or all at once (i.e., with a matrix).
* The scaling function acts as a "bottom" to the recursion/sub-banding because we need to stop somewhere.
** That being said, we also have to stop once we reach the resolution of the original signal.
* The scaling function also shows "trends" in the signal. Thanks to it, we can be sure that we don't miss any frequencies in the signal. In other words, it fixes the problem which in CWT is addressed by using complex numbers.
--
+
**_Forward DWT:_**
+
[stem]
++++
\begin{aligned}

A_{j_0}(k) &= \frac{1}{\sqrt{M}} \sum_{m=0}^{M-1} f(m) \cdot \varphi_{j_0,k}(m) \\

D_j(k) &= \frac{1}{\sqrt{M}} \sum_{m=0}^{M-1} f(m) \cdot \psi_{j,k}(m)

\end{aligned}
++++
+
**_Inverse DWT:_**
+
[stem]
++++
\begin{aligned}

f(m) = \frac{1}{\sqrt{M}} \sum_{k=0}^{2^{j_0}-1} A_{j_0}(k) \cdot \phi{j_0, k}(m) + \frac{1}{\sqrt{M}} \sum_{j=j_0}^{J-1} \sum_{k=0}^{2^j-1} D_j(k) \cdot \psi_{j,k}(m)

\end{aligned}
++++
+
where
+
--
* stem:[\varphi] and stem:[\psi] -- Orthogonal scaling and wavelet functions respectively.
* stem:[A_{j_0}] -- Scaling coefficients, approximations for low frequencies (low = in the stem:[j_0] sub-band).
* stem:[D_{j}] -- Wavelet coefficients, details for high frequencies (high = in the stem:[j] sub-band).
* stem:[k \in \{0, 1, ..., 2^j - 1\}]
--
+
image::./img/fa03_dwt_coefficients.png[]

The Haar scaling and wavelet functions in DWT:: 
We shift and scale the _scaling function stem:[\varphi_{j,k}]_ to cover the whole signal stem:[f] with length stem:[M]:
+
[stem]
++++
\varphi_{j,k}(x) = 2^{j/2} \cdot \varphi(2^j \frac{x}{M} - k)
++++
+
where:
+
--
* stem:[j] -- Scale (stretch).
* stem:[k] -- Shift along x-axis.
--
+
With growing stem:[j], stem:[\varphi{j,k}] covers a smaller fraction of the original signal range:
+
image::./img/fa03_dwt_scaling_function.png[]
+
We shift and scale the _Haar wavelet_ in much the same way:
+
[stem]
++++
\psi_{j,k}(x) = 2^{j/2} \cdot \psi(2^j \frac{x}{M} - k)
++++
+
image::./img/fa03_dwt_haar_wavelet.png[]
+
NOTE: Notice that stem:[\varphi] is a box filter (a low-pass filter), whereas stem:[\psi] is a difference filter (a high-pass filter). Both functions are orthogonal to their integer shifts because their range is stem:[\langle 0, 1 \rangle].

Filterbank::
An array of bandpass filters that separate the original signal into multiple components, each carrying information about a sub-band.

DWT with the Haar functions::
* stem:[\varphi_{j,k}] and stem:[\psi_{j,k}] form the basis of the DWT.
* stem:[j] controls which sub-band is analyzed; it's the _decomposition level_.
** stem:[0 \leq j < \log_2(M)] covers all frequencies.
** stem:[0 \ll j_0 < \log_2(M)] focuses on high-frequencies (stem:[j_0] is the lowest decomposition level).
* stem:[k \in \{0, 1, ..., 2^j-1\}] shifts the focus the the k-th "fraction" of the signal being decomposed.
* Haar wavelets are given explicitly. The other families are _enumerated_ (given by a table of values).

Fast discrete wavelet transform (FastDWT)::
Each step corresponds to convolution with a high-pass and low-pass decomposition filter followed by down-sampling.
+
--
* It performs sub-band coding.
* If it has odd length, we pad it from the right.
* Has complexity stem:[\mathcal{O}(n)] compared to FFT's stem:[\mathcal{O}(n\log n)].
--

Fast lifting wavelet transform (LiftingWT)::
An even faster DWT than FastDWT. The idea is the same as in FastDWT except the transition between decomposition levels is computed differently. It gets rid off the convolution and tries to "predict" the data instead. Has three broad phases:
+
--
1. **Split** into _odd_ and _even_ samples. (AKA _the lazy wavelet_)
2. **Predict** the _odd_ samples based on the _even_ samples and store the difference between the actual and predicted values (_error_) instead of the actual odd samples. (AKA _dual lifting_)
3. **Update** the _even_ samples by adding the _error_. (AKA _primal lifting_)
4. (**Normalize** the output to avoid boosting the original signal.)
--
+
image::./img/fa03_lifting_wt.png[]
+
Compared to FastDWT, LiftingWT:
+
--
* Requires less memory, since it can be computed in-place (overwriting the previous values).
* Can be computed on integers only, avoiding floating-point arithmetic.
--

2D DWT::
We use these functions:
+
--
* stem:[\varphi(x, y) = \varphi(x) \cdot \varphi(y)] scaling function at row stem:[y] and column stem:[x].
* stem:[\psi^H(x, y) = \psi(x) \cdot \varphi(y)] intensity variantions along **columns**.
* stem:[\psi^V(x, y) = \varphi(x) \cdot \psi(y)] intensity variantions along **rows**.
* stem:[\psi^D(x, y) = \psi(x) \cdot \psi(y)] intensity variantions along **diagonals**.
--
+
image::./img/fa03_2d_dwt.png[]
+
--
Used for edge detection, removal of high frequencies, image compression (JPEG 2000) (e.g., for fingerprint databases), image fusion (merging photos)
--

== Questions

====

Explain the relationship between DFT and DCT.::
DCT uses DFT under the hood. It uses some properties of DFT to remove the imaginary part of the result. As a result DCT uses some of the nice properties of DFT.

Describe the F-DCT algorithm and compute stem:[\text{F-DCT}\lparen\lbrack 1, 6, 6, 1 \rbrack\rparen].::
See F-DCT above.


====

[Bibliography]
== Sources

* PV291
* PV229
* Artem Kirsanov, link:https://www.youtube.com/watch?v=jnxqHcObNK4[Wavelets: a mathematical microscope], 2022
* PolyValens, link:http://www.polyvalens.com/wavelets/theory[A Really Friendly Guide To Wavelets]
